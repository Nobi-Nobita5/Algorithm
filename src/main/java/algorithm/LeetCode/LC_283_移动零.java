package algorithm.LeetCode;

/**
 * 给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
 *
 * 请注意 ，必须在不复制数组的情况下原地对数组进行操作。
 *
 *  
 *
 * 示例 1:
 *
 * 输入: nums = [0,1,0,3,12]
 * 输出: [1,3,12,0,0]
 * 示例 2:
 *
 * 输入: nums = [0]
 * 输出: [0]
 *  
 *
 * 提示:
 *
 * 1 <= nums.length <= 104
 * -231 <= nums[i] <= 231 - 1
 */
public class LC_283_移动零 {
    /**
     *
     * -------------------------------------------
     * 思路：
     * 使用同向双指针：右指针不断向右移动，每次当右指针指向非零数，则将左右指针对应的数交换，同时左指针右移。
     *            1.开始，左右指针初始都在最左边，往右移动，可以发现：当左右指针都指向非零时，自身做交换后又同时右移，那么两指针会一直在一起。
     *            2.只有当左右指针右移时遇到零，则不做自身交换，左指针不动，右指针继续右移。
     *            3.当右指针遇到非零，再做交换，同时左右指针右移。
     *            4.那么后续，左指针会指向零，右指针一直寻找非零。
     *            5.重复步骤3，直至右指针越界。
     * 注意到以下性质：
     * 左指针左边均为非零数；
     * 右指针左边直到左指针处均为零。
     * 因此每次交换，都是将左指针的零与右指针的非零数交换，且非零数的相对顺序并未改变。
     *
     * 时间复杂度：O(N)
     * @param nums
     */
    public void moveZeroes(int[] nums) {
        int i = 0,j = 0, n = nums.length;
        while (j<n){
            if (nums[j] != 0){
                int t = nums[i];
                nums[i] = nums[j];
                nums[j] = t;
                i++;
            }
            j++;
        }
    }

    /**
     * 同样是同向双指针，投机取巧了：因为知道是0，就不交换直接覆盖，最后补零
     * @param nums
     */
    public void moveZeroes1(int[] nums) {
        int left = 0;
        int right = 0;
        int m = nums.length;

        while(right<m){
            if(nums[right] != 0) {
                nums[left++] = nums[right];
            }
            right++;
        }

        for(int i = left; i < m; i++){
            nums[i] = 0;
        }
    }
}
