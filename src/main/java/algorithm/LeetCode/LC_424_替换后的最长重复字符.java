package algorithm.LeetCode;

/**
 * 给你一个字符串 s 和一个整数 k 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 k 次。
 *
 * 在执行上述操作后，返回包含相同字母的最长子字符串的长度。
 *
 *  
 *
 * 示例 1：
 *
 * 输入：s = "ABAB", k = 2
 * 输出：4
 * 解释：用两个'A'替换为两个'B',反之亦然。
 * 示例 2：
 *
 * 输入：s = "AABABBA", k = 1
 * 输出：4
 * 解释：
 * 将中间的一个'A'替换为'B',字符串变为 "AABBBBA"。
 * 子串 "BBBB" 有最长重复字母, 答案为 4。
 *  
 *
 * 提示：
 *
 * 1 <= s.length <= 105
 * s 仅由大写英文字母组成
 * 0 <= k <= s.length
 *
 * ------------------------------------------------
 * 官方解释：
 * 我们可以枚举字符串中的每一个位置作为右端点，然后找到其最远的左端点的位置，满足该区间内除了出现次数最多的那一类字符之外，
 * 剩余的字符（即非最长重复字符）数量不超过k个。
 *
 * 这样我们可以想到使用双指针维护这些区间，每次右指针右移，如果区间仍然满足条件，那么左指针不移动，否则左指针至多右移一格，
 * 保证区间长度不减小。
 *
 * 虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了 k 个。但是这样的区间也同样不可能对答案产生贡献。当我们右指针移动到尽头，
 * 左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。
 *
 * 实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 26 的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，
 * 然后尝试用它更新重复字符出现次数的历史最大值，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可。
 *
 * ------------------------------------------------
 * 题目：替换后最长重复字符串
 * 思路：同向双指针（滑动窗口）
 * 注：
 * 不能用leetcode-3 Longest Substring Without Repeating Characters的做法，
 * 本题滑动窗口的左右指针的移动条件与leetcode-3不同
 *
 * 正确解法：左右指针达到最大距离后，右指针右移，左指针做判断是否右移，的滑动窗口；
 *           判断方法：用长度为26的数组维护每一个字符出现的次数，每次区间右移动，更新右移位置字符的出现次数，
 *                     同时更新字符出现次数的最大值，最后根据【当前窗口长度】-【次数最大值】，
 *                     得到要被替换的字符数量，大于k则左指针右移。
 *           循环，当我们右指针移动到尽头，左右指针对应的区间的长度必然对应一个长度最大的符合条件的区间。
 *
 * 虽然这样的操作会导致部分区间不符合条件，即该区间内非最长重复字符超过了 k 个。但是这样的区间也同样不可能对答案产生新贡献，答案一直都是right - left。
 * 时间复杂度：O(N)
 * "AABABBA"
 */
public class LC_424_替换后的最长重复字符 {
    public int characterReplacement(String s, int k) {
        int[] num = new int[26];
        int n = s.length();
        int maxn = 0;
        int left = 0, right = 0;
        while (right < n) {
            num[s.charAt(right) - 'A']++;
            maxn = Math.max(maxn, num[s.charAt(right) - 'A']);
            //更新当时字符出现次数的最大值。
            if (right - left + 1 - maxn > k) {
                num[s.charAt(left) - 'A']--;
                left++;
                //左窗口右移后，并不需要改变maxn的值，因为右窗口也同步右移了。right - left 保持不变
            }
            right++;
        }
        return right - left;//最后窗口的长度就是符合条件的长度
    }
}
