package algorithm.LeetCode;

/**
 * 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：
 * 'A' -> "1"
 * 'B' -> "2"
 * ...
 * 'Z' -> "26"
 * 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：
 *
 * "AAJF" ，将消息分组为 (1 1 10 6)
 * "KJF" ，将消息分组为 (11 10 6)
 * 注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。
 * 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。
 * 题目数据保证答案肯定是一个 32 位 的整数。
 *
 * 示例 1：
 * 输入：s = "12"
 * 输出：2
 * 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
 *
 * 示例 2：
 * 输入：s = "226"
 * 输出：3
 * 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
 *
 * 示例 3：
 * 输入：s = "06"
 * 输出：0
 * 解释："06" 无法映射到 "F" ，因为存在前导零（"6" 和 "06" 并不等价）。
 * ------------------------
 * 思路：
 * 1、定义状态方程：dp[i] 表示以s[i]结尾的解码方式的总数；
 * 2、特殊情况：当第一位数位0时，则不存在编码，所以总数为0；
 * 3、本题类似爬楼梯，dp[i] 可以通过两种情况得到：
 *      s[i]可以单独编码的情况得到；
 *      s[i - 1]和s[i] 可以联合编码的情况得到;
 *      所以状态转移方程：dp[i] = dp[i - 1] + dp[i - 2]。
 *      即【不考虑字符'0'】的情况下：以s[i]结尾的解码方式的总数 = s[i-1]结尾的解码方式的总数 + s[i-2]结尾的解码方式的总数。
 * 4、状态转移方程的使用：
 *      TODO 问题的关键在于必须考虑s[i] = ’0‘的特殊情况。
 *      首先：提供的字符串开头 '0' ，该字符串都是无法完成编码解码的。
 *           中间和尾部出现了 '0' ，该字符串可能可以解码成功。只要有'10','20'，即num >= 10 && num <= 26（num为'0'和前面一个字符组成的数字）。
 *
 *      1.处理开头出现了 '0' :直接返回0。
 *      2.将状态方程dp[i] = dp[i - 1] + dp[i - 2]转换为dp[i] = dp[i] + dp[i - 2]来使用。此处的dp[i]在被该方程赋值之前，有两种情况：
 *      如果s[i-1]是'0' : dp[i] = 0；（代码实现时，dp[i]默认就为0）。
 *                       那么状态方程计算时最终是：
 *                       1.在满足[10,26]的范围条件时，dp[i] = dp[i-2]；
 *                       2.不满足该条件时，dp[i]默认等于0。
 *      如果s[i-1]不是'0' : dp[i] = dp[i-1]；
 *                         那么状态方程计算时最终是: dp[i] = dp[i - 1] + dp[i - 2]。
 *
 */
public class LC_91_解码方法 {
    public static void main(String[] args) {
        int i = numDecodings("10");
        System.out.println(i);
    }
    public static int numDecodings(String s) {
        //当数组为空，或者以‘0’开头时，总数为0
        if (s.length() == 0 || s.charAt(0) == '0') return 0;
        //定义状态方程
        int[] dp = new int[s.length()];
        //初始化状态方程（只有一个数字且不为0时，总数为1）
        dp[0] = 1;

        //获得后边的状态方程
        for (int i = 1; i < s.length(); i ++){
            //判断s[i]是否等于0。
            if (s.charAt(i) != '0') dp[i] = dp[i - 1];//如果s[i-1]不是'0' : dp[i] = dp[i-1]；
            //获取s[i]和s[i-1]组合成的数字
            int num = 10 * (s.charAt(i - 1) - '0') + (s.charAt(i) - '0');
            //判断s[i]是否可以与s[i - 1] 进行编码
            if(num >= 10 && num <= 26){
                //可以，且i == 1时，dp[i - 1] + 1
                if (i == 1){
                    dp[i] = dp[i] + 1;//也需要根据s[i]是否为0，确定赋值操作前dp[i]的值。
                }else {
                    //可以，且i != 1时。
                    //将状态方程dp[i] = dp[i - 1] + dp[i - 2]转换为dp[i] = dp[i] + dp[i - 2]来使用。此处的dp[i]在被该方程赋值之前，有两种情况：
                    // *      如果s[i-1]是'0' : dp[i] = 0；（代码实现时，dp[i]默认就为0）
                    // *      如果s[i-1]不是'0' : dp[i] = dp[i-1]；
                    dp[i] = dp[i] + dp[i - 2];
                }
            }
        }
        return dp[s.length() - 1];
    }
}
